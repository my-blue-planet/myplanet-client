{
  "SimpleImage": "// @ts-ignore\nSimpleImage = createLib();\n// @ts-ignore\nfunction createLib() {\n    let id = 0;\n    let images = [];\n    const getCountry = async (long, lat) => {\n        const signal = 'getcountry' + Date.now();\n        show({ 'command': \"getCountry\", 'value': [long, lat], 'readysignal': signal, 'id': 0 });\n        return await asyncWaitFor(signal);\n    };\n    const asyncWaitFor = async (signal) => {\n        let answer = waitFor(signal);\n        while (!answer) {\n            await new Promise(r => setTimeout(r, 200));\n            answer = waitFor(signal);\n        }\n        return answer.payload;\n    };\n    class Base {\n    }\n    class Image {\n        id;\n        W;\n        H;\n        channels;\n        channelkeys;\n        constructor() {\n            images.push(this);\n            this.id = id++;\n        }\n        // private open(src: string) {\n        // \tconst payload = this.runCommand('open', src)\n        // \t// @ts-ignore\n        // \tthis.afterOpening(payload)\n        // }\n        // create(W: number, H: number, color: [number, number, number] = [200,200,240]) {\n        // \tconst payload = this.runCommand('create', [W, H, color])\n        // \t// @ts-ignore\n        // \tthis.afterOpening(payload)\n        // }\n        static async load(src) {\n            const im = new Image();\n            const payload = await im.runCommandAsync('open', src);\n            im.afterOpening(payload);\n            return im;\n        }\n        static async create(W, H, color = [200, 200, 240]) {\n            const im = new Image();\n            const payload = await im.runCommandAsync('create', [W, H, color]);\n            im.afterOpening(payload);\n            return im;\n        }\n        // static async createSync(W: number, H: number, color: [number, number, number] = [200,200,240]) {\n        // \tconst im = new Image()\n        // \tconst payload = im.runCommand('create', [W, H, color])\n        // \tim.afterOpening(payload)\n        // \treturn im\n        // }\n        afterOpening(payload) {\n            this.W = payload['W'];\n            this.H = payload['H'];\n            this.channels = payload['channels'];\n            this.channelkeys = payload['channels'].map(c => `${this.id}_${c}`);\n        }\n        getId() { return this.id; }\n        async imageWaitFor(signal) {\n            return asyncWaitFor(signal);\n        }\n        // imageWaitForSync(signal: string) {\n        // \tlet answer = waitFor(signal)\n        // \tlet i = 0\n        // \twhile(!answer) {\n        // \t\tif(i++ % 1e6 === 0) {\n        // \t\t\tconsole.log(i);\n        // \t\t}\n        // \t\tanswer = waitFor(signal)\n        // \t}\n        // \treturn answer.payload\n        // }\n        // runCommand(command: string, value: unknown) {\n        // \tconst signal = 'image'+command+Date.now()\n        // \tshow({'command': command, 'value': value, 'readysignal': signal, 'id': this.id})\n        // \treturn this.imageWaitForSync(signal)\n        // }\n        async runCommandAsync(command, value) {\n            const signal = 'image' + command + Date.now();\n            show({ 'command': command, 'value': value, 'readysignal': signal, 'id': this.id });\n            return await this.imageWaitFor(signal);\n        }\n        // runCommandImmediate(command: string, value: unknown) {\n        // \tconst signal = false\n        // \tshow({'command': command, 'value': value, 'readysignal': signal, 'id': this.id})\n        // }\n        writePos(channel, pos, val) {\n            if (Math.random() < 0.0002)\n                console.log(`${this.getId()}_${channel}`);\n            return writeShared(`${this.getId()}_${channel}`, pos, val);\n        }\n        readPos(channel, pos) {\n            return readShared(`${this.getId()}_${channel}`, pos);\n        }\n        getWidth() { return this.W; }\n        getHeight() { return this.H; }\n        getDimensions() { return [this.W, this.H]; }\n        getPixel(x, y) {\n            return new Pixel(this, x, y);\n        }\n        getPixels() {\n            let x = 0;\n            let y = 0;\n            let img = this;\n            return {\n                [Symbol.iterator]() { return this; },\n                next() {\n                    if (y < img.H) {\n                        const p = new Pixel(img, x, y);\n                        x = (x + 1) % img.W;\n                        if (x === 0)\n                            y++;\n                        return { value: p, done: false };\n                    }\n                    else {\n                        return { done: true };\n                    }\n                }\n            };\n        }\n        setChannelAt(channel, x, y, val) {\n            const pos = x + y * this.getWidth();\n            return this.writePos(channel, pos, val);\n        }\n        setColorAt(x, y, color) {\n            const pos = x + y * this.getWidth();\n            for (let i = 0; i < color.length; i++) {\n                this.writePos(this.channels[i], pos, color[i]);\n            }\n        }\n        getChannelAt(channel, x, y) {\n            const pos = x + y * this.getWidth();\n            return this.readPos(channel, pos);\n        }\n        getColorAt(x, y) {\n            const pos = x + y * this.getWidth();\n            return this.channelkeys.map(k => readShared(k, pos));\n        }\n    }\n    class Series {\n    }\n    class Channel {\n        constructor() { }\n    }\n    class Pixel {\n        img;\n        x;\n        y;\n        p;\n        constructor(img, x, y) {\n            this.img = img;\n            this.x = x;\n            this.y = y;\n            this.p = x + y * img.getWidth();\n        }\n        setChannel(channel, value) {\n            return this.img.setChannelAt(channel, this.x, this.y, value);\n        }\n        getChannel(channel) {\n            return this.img.getChannelAt(channel, this.x, this.y);\n        }\n        toString() {\n            return `Pixel(${this.x}, ${this.y}): {}`;\n        }\n    }\n    return { Image, Channel, Series, getCountry };\n}\n// def getNeighbors(self):\n// neighbors = []\n// x = self.x\n// y = self.y\n// H = self.img.getHeight()\n// W = self.img.getWidth()\n// if y > 0:\n// neighbors.append(self.img.getPixel(x, y-1))\n// if y < H-1:\n// neighbors.append(self.img.getPixel(x, y+1))\n// if x > 0:\n// neighbors.append(self.img.getPixel(x-1, y))\n// if x < W-1:\n// neighbors.append(self.img.getPixel(x+1, y))\n// return neighbors\n//\n// #alias\n// def getNeighbours(self):\n// return self.getNeighbors()\n",
  "myplanet": "const channelAliases = {\n    r: [\"r\", \"R\", \"red\", \"rot\"],\n    g: [\"g\", \"G\", \"green\", \"gruen\", \"grün\"],\n    b: [\"b\", \"B\", \"blue\", \"blau\"],\n    a: [\"a\", \"A\", \"alpha\", \"alpha\"],\n    elevation: [\"h\", \"H\", \"elevation\", \"hoehe\", \"höhe\"],\n    country: [\"c\", \"C\", \"country\", \"land\"],\n    pop: [\"p\", \"P\", \"pop\", \"bev\"],\n    nox: [\"n\", \"N\", \"nox\", \"NOx\"],\n    night: [\"l\", \"L\", \"night\", \"nacht\", \"light\", \"nightlight\", \"licht\"],\n};\n// @ts-ignore\nmyplanet = createMyplanetLib();\nclass MercatorWorker {\n    static EarthRadius = 6378137;\n    static metersPerPixel(latitude, zoomLevel) {\n        return Math.cos(latitude * Math.PI / 180) * 2 * Math.PI * this.EarthRadius / this.getMapSize(zoomLevel);\n    }\n    static getMapSize(zoomLevel) {\n        return Math.ceil(256 * Math.pow(2, zoomLevel));\n    }\n    static clip(n, minValue, maxValue) {\n        return Math.min(Math.max(n, minValue), maxValue);\n    }\n    static worldPixelToPosition(px, py, zoomLevel) {\n        var mapSize = this.getMapSize(zoomLevel);\n        var x = (this.clip(px, 0, mapSize - 1) / mapSize) - 0.5;\n        var y = 0.5 - (this.clip(py, 0, mapSize - 1) / mapSize);\n        return [\n            360 * x,\n            90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI //Latitude\n        ];\n    }\n}\nfunction createMyplanetLib() {\n    const asyncWaitFor = async (signal) => {\n        let answer = waitFor(signal);\n        while (!answer) {\n            await new Promise(r => setTimeout(r, 200));\n            answer = waitFor(signal);\n        }\n        return answer.payload;\n    };\n    let globalChannelkeys = [];\n    class Messenger {\n        async imageWaitFor(signal) {\n            return asyncWaitFor(signal);\n        }\n        async runCommandAsync(command, value) {\n            const signal = 'image' + command + Date.now();\n            show({ 'command': command, 'value': value, 'readysignal': signal });\n            return await this.imageWaitFor(signal);\n        }\n    }\n    class LocatedMessenger extends Messenger {\n        zoomLevel;\n        worldCoords;\n        W;\n        H;\n        getPosition(px, py) {\n            return MercatorWorker.worldPixelToPosition(this.worldCoords[0] + px, this.worldCoords[1] + py, this.zoomLevel);\n        }\n        metersPerPixel(px, py) {\n            return MercatorWorker.metersPerPixel(this.getPosition(px, py)[1], this.zoomLevel);\n        }\n    }\n    class Scene extends LocatedMessenger {\n        sceneId;\n        channels;\n        channelkeys;\n        label;\n        collectionId;\n        didWarn;\n        static async load(src) {\n            const scene = new Scene();\n            const payload = await scene.runCommandAsync('open', src);\n            scene.afterOpening(payload);\n            return scene;\n        }\n        static fromCollectionFrame(config) {\n            const scene = new Scene();\n            scene.afterOpening(config);\n            return scene;\n        }\n        afterOpening(payload) {\n            this.W = payload['W'];\n            this.H = payload['H'];\n            this.zoomLevel = payload['zoomLevel'];\n            this.worldCoords = payload['worldCoords'];\n            this.label = payload[\"label\"] || \"\";\n            this.sceneId = payload['sceneId'];\n            this.channels = payload['channels'];\n            this.channelkeys = payload['channels'].map(c => `${this.getId()}_${c}`);\n            globalChannelkeys = globalChannelkeys.concat(this.channelkeys);\n        }\n        writePos(channel, pos, val) {\n            const channelkey = `${this.getId()}_${channel}`;\n            if (this.warnIfNotExists(channelkey))\n                return;\n            writeShared(channelkey, pos, val);\n            //if read first performance is about the same\n            return writeShared(\"dirtymarkers\", globalChannelkeys.indexOf(channelkey), 1);\n        }\n        readPos(channel, pos) {\n            const channelkey = `${this.getId()}_${channel}`;\n            if (this.warnIfNotExists(channelkey))\n                return;\n            return readShared(channelkey, pos);\n        }\n        warnIfNotExists(channelkey) {\n            const missingChannel = !globalChannelkeys.includes(channelkey);\n            if (!this.didWarn && missingChannel) {\n                this.didWarn = true;\n                warn(`This scene does not include channel: ${channelkey.split(\"_\")[1]}`);\n            }\n            return missingChannel;\n        }\n        async addOverlay(label = \"\") {\n            const overlay = new Overlay();\n            const payload = await overlay.runCommandAsync('addOverlay', [this.getId(), label]);\n            overlay.afterOpening(payload);\n            return overlay;\n        }\n        forceChannel(channelname) {\n            return this.runCommandAsync('forceChannel', [this.getId(), channelname]);\n        }\n        contains(x, y) {\n            return x >= 0 && x < this.W && y >= 0 && y < this.H;\n        }\n        getId() { return this.sceneId; }\n        getWidth() { return this.W; }\n        getHeight() { return this.H; }\n        getDimensions() { return [this.W, this.H]; }\n        getPixel(x, y) {\n            return new Pixel(this, x, y);\n        }\n        getPixels() {\n            let x = 0;\n            let y = 0;\n            let scene = this;\n            return {\n                [Symbol.iterator]() { return this; },\n                next() {\n                    if (y < scene.H) {\n                        const p = new Pixel(scene, x, y);\n                        x = (x + 1) % scene.W;\n                        if (x === 0)\n                            y++;\n                        return { value: p, done: false };\n                    }\n                    else {\n                        return { done: true };\n                    }\n                }\n            };\n        }\n        get pixels() {\n            return this.getPixels();\n        }\n        getPixelSize() {\n            return this.metersPerPixel(this.worldCoords[0] + 0.5 * this.W, this.worldCoords[1] + 0.5 * this.H);\n        }\n        setChannelAt(channel, x, y, val) {\n            const pos = x + y * this.getWidth();\n            return this.writePos(channel, pos, val);\n        }\n        getChannelAt(channel, x, y) {\n            const pos = x + y * this.getWidth();\n            return this.readPos(channel, pos);\n        }\n    }\n    class Overlay extends Scene {\n        setChannelAt(channel, x, y, val) {\n            const pos = x + y * this.getWidth();\n            if (this.readPos(\"a\", pos) === 0)\n                this.writePos(\"a\", pos, 255);\n            return this.writePos(channel, pos, val);\n        }\n        setColorAt(x, y, color) {\n            const pos = x + y * this.getWidth();\n            if (this.readPos(\"a\", pos) === 0)\n                this.writePos(\"a\", pos, 255);\n            for (let i = 0; i < color.length; i++) {\n                this.writePos(this.channels[i], pos, color[i]);\n            }\n        }\n        addMarker(x, y) {\n            const R = Math.round(Math.min(this.W, this.H) / 80);\n            for (let dx = -2 * R; dx <= 2 * R; dx++) {\n                for (let dy = -2 * R; dy <= 2 * R; dy++) {\n                    if (this.contains(x + dx, y + dy)) {\n                        const r = (dx ** 2 + dy ** 2) ** 0.5;\n                        const dr = Math.abs(R - r);\n                        if (dr < 0.3 * R) {\n                            this.setChannelAt(\"r\", x + dx, y + dy, 255);\n                            this.setChannelAt(\"a\", x + dx, y + dy, dr < 0.2 * R ? 255 : 255 - Math.round(255 * (dr - 0.2 * R) / (0.1 * R)));\n                        }\n                    }\n                }\n            }\n        }\n    }\n    class Collection extends LocatedMessenger {\n        collectionId;\n        scenes;\n        afterOpening(payload) {\n            this.W = payload['W'];\n            this.H = payload['H'];\n            this.zoomLevel = payload['zoomLevel'];\n            this.worldCoords = payload['worldCoords'];\n            this.collectionId = payload['collectionId'];\n            let sceneIds = payload[\"sceneIds\"];\n            this.scenes = sceneIds.map((sceneId, index) => {\n                const scene = Scene.fromCollectionFrame({\n                    \"W\": payload[\"W\"],\n                    \"H\": payload[\"H\"],\n                    \"worldCoords\": payload['worldCoords'],\n                    \"zoomLevel\": payload['zoomLevel'],\n                    sceneId,\n                    \"channels\": payload[\"channels\"][index],\n                    \"label\": payload[\"labels\"][index]\n                });\n                scene.collectionId = this.collectionId;\n                return scene;\n            });\n        }\n        static async load(src) {\n            const collection = new Collection();\n            const payload = await collection.runCommandAsync('openCollection', src);\n            collection.afterOpening(payload);\n            return collection;\n        }\n        async addOverlay(label = \"\") {\n            const overlay = new Overlay();\n            const payload = await overlay.runCommandAsync('addCollectionOverlay', [this.getId(), label]);\n            overlay.afterOpening(payload);\n            overlay.collectionId = this.getId();\n            return overlay;\n        }\n        forceFrame(sceneOrLabel) {\n            const scene = sceneOrLabel instanceof Scene ? sceneOrLabel : this.scenes.find(s => s.label === sceneOrLabel);\n            this.runCommandAsync('forceFrame', [this.getId(), this.scenes.indexOf(scene)]);\n        }\n        getId() { return this.collectionId; }\n        getScenes() { return this.scenes; }\n    }\n    class Pixel {\n        scene;\n        x;\n        y;\n        p;\n        constructor(scene, x, y) {\n            this.scene = scene;\n            this.x = x;\n            this.y = y;\n            this.p = x + y * scene.getWidth();\n        }\n        setChannel(channel, value) {\n            return this.scene.setChannelAt(channel, this.x, this.y, value);\n        }\n        getChannel(channel) {\n            return this.scene.getChannelAt(channel, this.x, this.y);\n        }\n        getSizeInMeters() {\n            return this.scene.metersPerPixel(this.x, this.y);\n        }\n        get size() {\n            return this.getSizeInMeters();\n        }\n        getAreaInKm2() {\n            return 0.000001 * this.size * this.size;\n        }\n        get people() {\n            return (this.getChannel(\"pop\") || 0) * this.getAreaInKm2();\n        }\n        getBrightness() {\n            return (this.getChannel(\"r\") + this.getChannel(\"g\") + this.getChannel(\"b\")) / 3;\n        }\n        get brightness() {\n            return this.getBrightness();\n        }\n        toString() {\n            const obj = Object.fromEntries(this.scene.channels.map(c => [c, this.scene.getChannelAt(c, this.x, this.y)]));\n            return `Pixel(${this.x}, ${this.y}): ${JSON.stringify(obj)}`;\n        }\n        getNeighbours(includeDiagonal = false) {\n            const addPixelIfExists = (list, x, y) => {\n                if (this.scene.contains(x, y))\n                    list.push(this.scene.getPixel(x, y));\n            };\n            const neighbours = [];\n            let x = this.x;\n            let y = this.y;\n            addPixelIfExists(neighbours, x, y - 1);\n            addPixelIfExists(neighbours, x, y + 1);\n            addPixelIfExists(neighbours, x - 1, y);\n            addPixelIfExists(neighbours, x + 1, y);\n            if (includeDiagonal) {\n                addPixelIfExists(neighbours, x - 1, y - 1);\n                addPixelIfExists(neighbours, x - 1, y + 1);\n                addPixelIfExists(neighbours, x + 1, y - 1);\n                addPixelIfExists(neighbours, x + 1, y + 1);\n            }\n            return neighbours;\n        }\n        getNeighbors(includeDiagonal = false) {\n            return this.getNeighbours(includeDiagonal);\n        }\n    }\n    for (let channelAlias of Object.entries(channelAliases)) {\n        const [name, aliases] = channelAlias;\n        for (let alias of [...new Set(aliases)]) {\n            Object.defineProperty(Pixel.prototype, alias, {\n                get() { return this.getChannel(name); },\n                set(val) { return this.setChannel(name, val); }\n            });\n        }\n    }\n    return { Scene, Pixel, Collection };\n}\n"
}