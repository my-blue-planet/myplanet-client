{
  "SimpleImage": {
    "src/lib/SimpleImage.py": "from time import sleep, clock\n\"\"\"\ncreate a decorator to add functions as methods\nwith this decorators all functions are usable global\nand as method\ndef add_method(cls):\n\tdef decorator(func):\n\t\tdef wrapper(self, *args, **kwargs):\n\t\t\treturn func(*args, **kwargs)\n\t\tsetattr(cls, func.__name__, wrapper)\n\t\t# Note we are not binding func, but wrapper which accepts self but does exactly the same as func\n\t\treturn func # returning func means func can still be used normally\n\treturn decorator\n\"\"\"\nid = 0\nimages = []\ndef _asyncWaitFor(signal):\n  answer = waitFor(signal)\n  while not answer:\n    answer = waitFor(signal)\n    sleep(0.002)\n  return answer['payload']\ndef getCountry(long, lat):\n  signal = 'getcountry'+str(round(clock()*1e6))\n  show({'command': 'getCountry', 'value': [long, lat], 'readysignal': signal, 'id': 0})\n  return _asyncWaitFor(signal)\nclass Image:\n\tdef __init__(self, srcOrW, H=7, color=None):\n\t\tglobal id\n\t\tglobal images\n\t\timages.append(self)\n\t\tself.id = id\n\t\tid = id + 1\n\t\tif isinstance(srcOrW, str):\n\t\t\tself._open(srcOrW)\n\t\telif isinstance(srcOrW, int) and isinstance(H, int):\n\t\t\tself._create(srcOrW, H, color)\n\t\telse:\n\t\t\tprint('Bitte Bildquelle oder BildgrÃ¶sse angeben.')\n\t@classmethod\n\tdef open(cls, url):\n\t\treturn cls(url)\n\t@classmethod\n\tdef create(cls, W, H, color):\n\t\treturn cls(W, H, color)\n\t@classmethod\n\tdef new(cls, W, H, color=None):\n\t\treturn cls(W, H, color)\n\tdef getId(self):\n\t\treturn self.id\n\tdef imageWaitFor(self, signal):\n\t\treturn _asyncWaitFor(signal)\n\tdef runCommand(self, command, value):\n\t\tsignal = 'image'+command+str(round(clock()*1e6))\n\t\tshow({'command': command, 'value': value, 'readysignal': signal, 'id': self.id})\n\t\treturn self.imageWaitFor(signal)\n\tdef runCommandImmediate(self, command, value):\n\t\tsignal = False\n\t\tshow({'command': command, 'value': value, 'readysignal': signal, 'id': self.id})\n\tdef _open(self, src):\n\t\tpayload = self.runCommand('open', src)\n\t\tself._afterOpening(payload)\n\tdef _create(self, W, H, color):\n\t\tif color == None:\n\t\t\tcolor = [200,200,240]\n\t\tpayload = self.runCommand('create', [W, H, color])\n\t\tself._afterOpening(payload)\n\tdef _afterOpening(self, payload):\n\t\tself.W = payload['W']\n\t\tself.H = payload['H']\n\t\tself.channels = payload['channels']\n\t\tself.channelkeys = [str(self.getId()) + \"_\" + c for c in self.channels]\n\tdef _writePos(self, channel, pos, val):\n\t\treturn writeShared(str(self.getId()) + \"_\" + channel, pos, val)\n\tdef _readPos(self, channel, pos):\n\t\treturn readShared(str(self.getId()) + \"_\" + channel, pos)\n\tdef getWidth(self):\n\t\treturn self.W\n\tdef getHeight(self):\n\t\treturn self.H\n\tdef getDimensions(self):\n\t\treturn [self.W, self.H]\n\tdef getPixel(self, x, y):\n\t\treturn Pixel(self, x, y)\n\tdef setChannelAt(self, channel, x, y, val):\n\t\tpos = x + y * self.getWidth()\n\t\treturn self._writePos(channel, pos, val)\n\tdef setColorAt(self, x, y, color):\n\t\tpos = x + y * self.getWidth()\n\t\tfor channel in range(len(color)):\n\t\t\twriteShared(self.channelkeys[channel], pos, color[channel])\n\t\treturn\n\tdef getChannelAt(self, channel, x, y):\n\t\tpos = x + y * self.getWidth()\n\t\treturn self._readPos(channel, pos)\n\tdef getColorAt(self, x, y):\n\t\tpos = x + y * self.getWidth()\n\t\treturn [readShared(channel, pos) for channel in self.channelkeys]\nclass Pixel:\n\tdef __init__(self, img, x, y):\n\t\tself.img = img\n\t\tself.__x = x\n\t\tself.__y = y\n\t\tself.__p = x + y * img.getWidth()\n\tdef __getx(self):\n\t\treturn self.__x\n\tx = property(__getx)\n\t\n\tdef __gety(self):\n\t\treturn self.__y\n\ty = property(__gety)\n\t\n\tdef setChannel(self, channel, value):\n\t\treturn self.img.setChannel(channel, self.x, self.y, value)\n\tdef getChannel(self, channel):\n\t\treturn self.img.getChannelAt(channel, self.x, self.y)\n\t#alias\n\tdef set(self, channel, value):\n\t\treturn self.img.getChannelAt(channel, self.x, self.y)\n\t#alias\n\tdef get(self, channel):\n\t\treturn self.img._readPos(channel, self.__p)\n\tdef __str__(self):\n\t\tlog = \"Pixel(%d,%d): {\" % (self.x, self.y)\n\t\tfor channel in self.img.channels:\n\t\t\tlog += channel + \":\" + str(self.getChannel(channel)) + \"  \"\n\t\tlog += \"}\"\n\t\treturn log\n\t\n\tdef getNeighbors(self):\n\t\tneighbors = []\n\t\tx = self.x\n\t\ty = self.y\n\t\tH = self.img.getHeight()\n\t\tW = self.img.getWidth()\n\t\tif y > 0:\n\t\t\tneighbors.append(self.img.getPixel(x, y-1))\n\t\tif y < H-1:\n\t\t\tneighbors.append(self.img.getPixel(x, y+1))\n\t\tif x > 0:\n\t\t\tneighbors.append(self.img.getPixel(x-1, y))\n\t\tif x < W-1:\n\t\t\tneighbors.append(self.img.getPixel(x+1, y))\n\t\treturn neighbors\n\t#alias\n\tdef getNeighbours(self):\n\t\treturn self.getNeighbors()\n"
  },
  "myplanet": {
    "src/lib/myplanet.py": "from time import sleep, clock\nfrom mercatorWorker import worldPixelToPosition, metersPerPixel\ndef _asyncWaitFor(signal):\n  answer = waitFor(signal)\n  while not answer:\n    answer = waitFor(signal)\n    sleep(0.002)\n  return answer['payload']\nglobalChannelKeys = []\nclass Messenger:\n\tdef waitForSignal(self, signal):\n\t\treturn _asyncWaitFor(signal)\n\tdef runCommand(self, command, value):\n\t\tsignal = 'image'+command+str(round(clock()*1e6))\n\t\tshow({'command': command, 'value': value, 'readysignal': signal})\n\t\treturn self.waitForSignal(signal)\n\tdef runCommandImmediate(self, command, value):\n\t\tsignal = False\n\t\tshow({'command': command, 'value': value, 'readysignal': signal})\nclass LocatedMessenger(Messenger):\n\tdef getPosition(self, px, py):\n\t\treturn worldPixelToPosition(self.worldCoords[0] + px, self.worldCoords[1] + py, self.zoomLevel)\n\tdef metersPerPixel(self, px, py):\n\t\treturn metersPerPixel(self.getPosition(px, py)[1], self.zoomLevel)\nclass Scene(LocatedMessenger):\n\t@classmethod\n\tdef load(cls, src):\n\t\tscene = cls()\n\t\tpayload = scene.runCommand('open', src)\n\t\tscene._afterOpening(payload)\n\t\treturn scene\n\t@classmethod\n\tdef fromCollectionFrame(cls, config):\n\t\tscene = cls()\n\t\tscene._afterOpening(config)\n\t\treturn scene\n\tdef _afterOpening(self, payload):\n\t\tglobal globalChannelKeys\n\t\tself.W = payload['W']\n\t\tself.H = payload['H']\n\t\tself.zoomLevel = payload['zoomLevel']\n\t\tself.worldCoords = payload['worldCoords']\n\t\tself.label = payload.get(\"label\", \"\")\n\t\tself.sceneId = payload['sceneId']\n\t\tself.channels = payload['channels']\n\t\tself.channelkeys = [str(self.getId()) + \"_\" + c for c in self.channels]\n\t\tglobalChannelKeys += self.channelkeys\n\tdef _writePos(self, channel, pos, val):\n\t\tglobal writeShared\n\t\tglobal globalChannelKeys\n\t\tchannelkey = str(self.getId()) + \"_\" + channel\n\t\twriteShared(channelkey, pos, val)\n\t\treturn writeShared(\"dirtymarkers\", globalChannelKeys.index(channelkey), 1)\n\tdef _readPos(self, channel, pos):\n\t\tglobal readShared\n\t\treturn readShared(str(self.getId()) + \"_\" + channel, pos)\n\tdef addOverlay(self, label=\"\"):\n\t\toverlay = Overlay()\n\t\tpayload = overlay.runCommand('addOverlay', [self.getId(), label])\n\t\toverlay._afterOpening(payload)\n\t\treturn overlay\n\tdef forceChannel(self, channelname):\n\t\tself.runCommand('forceChannel', [self.getId(), channelname])\n\tdef contains(self, x, y):\n\t\treturn 0 <= x < self.W and 0 <= y < self.H\n\tdef getId(self):\n\t\treturn self.sceneId\n\tdef getWidth(self):\n\t\treturn self.W\n\tdef getHeight(self):\n\t\treturn self.H\n\tdef getDimensions(self):\n\t\treturn [self.W, self.H]\n\tdef getPixel(self, x, y):\n\t\treturn Pixel(self, x, y)\n\tdef getPixels(self):\n\t\tfor y in range(self.H):\n\t\t\tfor x in range(self.W):\n\t\t\t\tyield Pixel(self, x, y)\n\t@property\n\tdef pixels(self):\n\t\treturn self.getPixels()\n\tdef getPixelSize(self):\n\t\treturn self.metersPerPixel(self.worldCoords[0] + 0.5*self.W, self.worldCoords[1] + 0.5*self.H)\n\t\n\tdef setChannelAt(self, channel, x, y, val):\n\t\tif(not channel in self.channels):\n\t\t\traise Exception(\"Channel not available: \" + channel)\n\t\tpos = x + y * self.getWidth()\n\t\treturn self._writePos(channel, pos, val)\n\tdef getChannelAt(self, channel, x, y):\n\t\tif(not channel in self.channels):\n\t\t\traise Exception(\"Channel not available: \" + channel)\n\t\tpos = x + y * self.getWidth()\n\t\treturn self._readPos(channel, pos)\nclass Overlay(Scene):\n\tdef setChannelAt(self, channel, x, y, val):\n\t\tpos = x + y * self.getWidth()\n\t\tif self._readPos(\"a\", pos) == 0:\n\t\t\tself._writePos(\"a\", pos, 255)\n\t\treturn self._writePos(channel, pos, val)\n\tdef setColorAt(self, x, y, color):\n\t\tpos = x + y * self.getWidth()\n\t\tif self._readPos(\"a\", pos) == 0:\n\t\t\tself._writePos(\"a\", pos, 255)\n\t\tfor channel in range(len(color)):\n\t\t\twriteShared(self.channelkeys[channel], pos, color[channel])\n\t\treturn\n\tdef addMarker(self, x, y):\n\t\tR = round(min(self.W, self.H) / 80)\n\t\tfor dx in range(-2*R, 2*R+1):\n\t\t\tfor dy in range(-2*R, 2*R+1):\n\t\t\t\tif self.contains(x + dx, y + dy):\n\t\t\t\t\tr = (dx**2 + dy**2)**0.5\n\t\t\t\t\tdr = abs(R-r)\n\t\t\t\t\tif dr < 0.3*R:\n\t\t\t\t\t\tself.setChannelAt(\"r\", x + dx, y + dy, 255)\n\t\t\t\t\t\talpha = 255\n\t\t\t\t\t\tif dr > 0.2 * R:\n\t\t\t\t\t\t\talpha -= round(255 * (dr - 0.2*R) / (0.1*R))\n\t\t\t\t\t\tself.setChannelAt(\"a\", x + dx, y + dy, alpha)\nclass Collection(LocatedMessenger):\n\t@classmethod\n\tdef load(cls, url):\n\t\tcollection = cls()\n\t\tpayload = collection.runCommand('openCollection', url)\n\t\tcollection._afterOpening(payload)\n\t\treturn collection\n\tdef _afterOpening(self, payload):\n\t\tglobal globalChannelKeys\n\t\tself.W = payload['W']\n\t\tself.H = payload['H']\n\t\tself.zoomLevel = payload['zoomLevel']\n\t\tself.worldCoords = payload['worldCoords']\n\t\tself.collectionId = payload['collectionId']\n\t\tself.scenes = []\n\t\tfor index, sceneId in enumerate(payload['sceneIds']):\n\t\t\tscene = Scene.fromCollectionFrame({\n\t\t\t\t\"W\": payload[\"W\"],\n\t\t\t\t\"H\": payload[\"H\"],\n\t\t\t\t\"worldCoords\": payload['worldCoords'],\n\t\t\t\t\"zoomLevel\": payload['zoomLevel'],\n\t\t\t\t\"sceneId\": sceneId,\n\t\t\t\t\"channels\": payload[\"channels\"][index],\n\t\t\t\t\"label\": payload[\"labels\"][index]\n\t\t\t})\n\t\t\tscene.collectionId = self.collectionId\n\t\t\tself.scenes.append(scene)\n\tdef addOverlay(self, label = \"\"):\n\t\toverlay = Overlay()\n\t\tpayload = overlay.runCommand('addCollectionOverlay', [self.getId(), label])\n\t\toverlay._afterOpening(payload)\n\t\toverlay.collectionId = self.getId()\n\t\treturn overlay\n\tdef findSceneByLabel(self, label):\n\t\tfor scene in self.scenes:\n\t\t\tif scene.label == label:\n\t\t\t\treturn scene\n\tdef forceFrame(self, sceneOrLabel):\n\t\tscene = sceneOrLabel if isinstance(sceneOrLabel, Scene) else self.findSceneByLabel(sceneOrLabel)\n\t\tself.runCommand('forceFrame', [self.getId(), self.scenes.index(scene)])\n\tdef getId(self):\n\t\treturn self.collectionId\n\tdef getScenes(self):\n\t\treturn self.scenes\nclass Pixel:\n\tdef __init__(self, scene, x, y):\n\t\tself.scene = scene\n\t\tself.__x = x\n\t\tself.__y = y\n\t\tself.__p = x + y * scene.getWidth()\n\t\n\t@classmethod\n\tdef create_channel_methods(cls):\n\t\tchannelAliases = {\n\t\t\t\"r\": [\"r\", \"R\", \"red\", \"rot\"],\n\t\t\t\"g\": [\"g\", \"G\", \"green\", \"gruen\", \"grÃ¼n\"],\n\t\t\t\"b\": [\"b\", \"B\", \"blue\", \"blau\"],\n\t\t\t\"a\": [\"a\", \"A\", \"alpha\", \"alpha\"],\n\t\t\t\"elevation\": [\"h\", \"H\", \"elevation\", \"hoehe\", \"hÃ¶he\"],\n\t\t\t\"country\": [\"c\", \"C\", \"country\", \"land\"],\n\t\t\t\"pop\": [\"p\", \"P\", \"pop\", \"bev\"],\n\t\t\t\"nox\": [\"n\", \"N\",  \"nox\", \"NOx\"],\n\t\t\t\"night\": [\"l\", \"L\", \"night\", \"nacht\", \"light\", \"nightlight\", \"licht\"],\n\t\t}\n\t\tdef createGetter(channel):\n\t\t\treturn lambda self: self.getChannel(channel)\n\t\tdef createSetter(channel):\n\t\t\treturn lambda self, val: self.setChannel(channel, val)\n\t\tfor name, aliases in channelAliases.items():\n\t\t\tfor alias in set(aliases):\n\t\t\t\tsetattr(cls, alias, property(createGetter(name), createSetter(name)))\n\t\n\tdef __getx(self):\n\t\treturn self.__x\n\tx = property(__getx)\n\t\n\tdef __gety(self):\n\t\treturn self.__y\n\ty = property(__gety)\n\t\n\tdef setChannel(self, channel, value):\n\t\treturn self.scene.setChannelAt(channel, self.x, self.y, value)\n\tdef getChannel(self, channel):\n\t\treturn self.scene.getChannelAt(channel, self.x, self.y)\n\tdef getSizeInMeters(self):\n\t\treturn self.scene.metersPerPixel(self.x, self.y)\n\tsize = property(getSizeInMeters)\n\t\t\n\tdef getAreaInKm2(self):\n\t\treturn 0.000001 * self.size * self.size\n\tdef countPeople(self):\n\t\treturn (self.getChannel(\"pop\") or 0) * self.getAreaInKm2()\n\tpeople = property(countPeople)\n\tdef getBrightness(self):\n\t\treturn (self.getChannel(\"r\") + self.getChannel(\"g\") + self.getChannel(\"b\")) / 3\n\tbrightness = property(getBrightness)\n\t#alias\n\tdef set(self, channel, value):\n\t\treturn self.scene.setChannelAt(channel, self.x, self.y, value)\n\t#alias\n\tdef get(self, channel):\n\t\treturn self.scene._readPos(channel, self.__p)\n\tdef __str__(self):\n\t\tlog = \"Pixel(%d,%d): {\" % (self.x, self.y)\n\t\tfor channel in self.scene.channels:\n\t\t\tlog += channel + \":\" + str(self.getChannel(channel)) + \"  \"\n\t\tlog += \"}\"\n\t\treturn log\n\t\n\tdef getNeighbours(self):\n\t\tdef addPixelIfExists(list, x, y):\n\t\t\tif self.scene.contains(x, y):\n\t\t\t\tlist.append(self.scene.getPixel(x, y)) \n\t\tneighbors = []\n\t\tx = self.x\n\t\ty = self.y\n\t\taddPixelIfExists(neighbors, x, y-1)\n\t\taddPixelIfExists(neighbors, x, y+1)\n\t\taddPixelIfExists(neighbors, x-1, y)\n\t\taddPixelIfExists(neighbors, x+1, y)\n\t\treturn neighbors\n\t#alias\n\tdef getNeighbors(self):\n\t\treturn self.getNeighbors()\nPixel.create_channel_methods()"
  },
  "keyboard": {
    "src/lib/keyboard.js": "//mimics this library: https://github.com/boppreh/keyboard\nexport const keyboardLib = {\n  \"src/lib/keyboard.py\": `\ndef isPressed(key):\n  return key in getworkerstate('pressed_keys')\ndef is_pressed(key):\n  return key in getworkerstate('pressed_keys')\ndef getPressedKeys():\n  return getworkerstate('pressed_keys')\n`\n};"
  },
  "threading": {
    "src/lib/threading.js": "const $builtinmodule = function (name) {\n\tconst mod = {};\n\tmod.parallel = new Sk.builtin.func(function(pyfns) {\n\t\tvar susp = new Sk.misceval.Suspension();\n\t\tsusp.resume = function (n) {\n\t\t\tif (susp.data[\"error\"]) {\n\t\t\t\tthrow new Sk.builtin.IOError(susp.data[\"error\"].message);\n\t\t\t}\n\t\t\treturn Sk.ffi.remapToPy(susp.data.result);\n\t\t}\n\t\tsusp.data = {\n\t\t\ttype: \"Sk.promise\",\n\t\t\tpromise: Promise.all(pyfns.v.map(pyfn => {\n\t\t\t\treturn Sk.misceval.callsimAsync(null, pyfn)\n\t\t\t}))\n\t\t};\n\t\treturn susp;\n\t});\n\tmod.add = new Sk.builtin.func(function(pyfn, ...args) {\n\t\tvar susp = new Sk.misceval.Suspension();\n\t\tlet done = false;\n\t\tlet result = Sk.ffi.remapToPy(\"undefined\");\n\t\tlet thread = {\n\t\t\tisDone: function() {return done},\n\t\t\tgetResult: function() {return result}\n\t\t}\n\t\tsusp.resume = function (n) {\n\t\t\tSk.misceval.callsimAsync(null, pyfn, ...args).then(x=>{\n\t\t\t\tresult = Sk.ffi.remapToPy(x);\n\t\t\t\tdone = true;\n\t\t\t})\n\t\t\tif (susp.data[\"error\"]) {\n\t\t\t\tthrow new Sk.builtin.IOError(susp.data[\"error\"].message);\n\t\t\t}\n\t\t\treturn Sk.ffi.remapToPy(susp.data.result);\n\t\t}\n\t\tsusp.data = {\n\t\t\ttype: \"Sk.promise\",\n\t\t\tpromise: Promise.resolve(thread)\n\t\t};\n\t\treturn susp;\n\t});\n\tmod.wait = new Sk.builtin.func(function(pymillis) {\n\t\tvar susp = new Sk.misceval.Suspension();\n\t\tlet millis = Sk.ffi.remapToJs(pymillis);\n\t\tsusp.resume = function (n) {\n\t\t\treturn Sk.ffi.remapToPy(susp.data.result);\n\t\t}\n\t\tsusp.data = {\n\t\t\ttype: \"Sk.promise\",\n\t\t\tpromise: new Promise((resolve, reject) => setTimeout(_=>resolve(millis), millis))\n\t\t};\n\t\treturn susp;\n\t});\n\treturn mod;\n}"
  },
  "mercatorWorker": {
    "src/lib/mercatorWorker.js": "class MercatorWorkerJS {\n\tstatic EarthRadius = 6378137\n\tstatic metersPerPixel(latitude, zoomLevel) {\n\t\treturn Math.cos(latitude * Math.PI / 180) * 2 * Math.PI * this.EarthRadius / this.getMapSize(zoomLevel);\n\t}\n\tstatic getMapSize(zoomLevel) {\n\t\treturn Math.ceil(256 * Math.pow(2, zoomLevel));\n\t}\n\tstatic clip(n, minValue, maxValue) {\n\t\treturn Math.min(Math.max(n, minValue), maxValue);\n\t}\n\tstatic worldPixelToPosition(px, py, zoomLevel) {\n\t\tvar mapSize = this.getMapSize(zoomLevel);\n\t\tvar x = (this.clip(px, 0, mapSize - 1) / mapSize) - 0.5;\n\t\tvar y = 0.5 - (this.clip(py, 0, mapSize - 1) / mapSize);\n\t\treturn [\n\t\t\t360 * x,    //Longitude\n\t\t\t90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI  //Latitude\n\t\t];\n\t}\n}\nconst $builtinmodule = function (name) {\n\tconst module = {};\n\tmodule.metersPerPixel = new Sk.builtin.func(function(latitudePyNum, zoomLevelPyNum) {\n\t\tlet jsLat = Sk.ffi.remapToJs(latitudePyNum)\n\t\tlet jsZoomLevel = Sk.ffi.remapToJs(zoomLevelPyNum)\n\t\tlet metersPerP = MercatorWorkerJS.metersPerPixel(jsLat, jsZoomLevel)\n\t\treturn Sk.ffi.remapToPy(metersPerP)\n\t});\n\tmodule.worldPixelToPosition = new Sk.builtin.func(function(pxPy, pyPy, zoomLevelPy) {\n\t\tlet pxJs = Sk.ffi.remapToJs(pxPy)\n\t\tlet pyJs = Sk.ffi.remapToJs(pyPy)\n\t\tlet zoomLevelJs = Sk.ffi.remapToJs(zoomLevelPy)\n\t\tlet longLat = MercatorWorkerJS.worldPixelToPosition(pxJs, pyJs, zoomLevelJs)\n\t\treturn Sk.ffi.remapToPy(longLat)\n\t});\n\treturn module;\n}"
  }
}